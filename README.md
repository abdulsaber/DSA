# Practice 
DAY-1

1. practice operators, Conditional satatements.

DAY-2

1. Write a Java program to find the numbers greater than the average of the numbers of a given array.
2. Write a Java program that takes a number as input and prints its multiplication table upto 10. 
3. Write a Java program to sum values of an array. 
4. Write a Java program to find the maximum and minimum value of an array. 
5. Write a Java program to separate Os on left side and 1s on right side of an array of Os and 1s inrandom order. 
6. Write a Java method to find the smallest number among three numbers. 
7. Write a Java method to print Fibonacci series of n terms where n is argument passed by user. 
8. Write a program to find the factorial value of any number entered through the keyboard.

DAY-3

1. Learn Time and Space complexity.
2. practice some questions

DAY-4 (Array)

1. Search in an Array.
2. Delete an element from an Array.
3. Find the largest element in an Array.
4. Find the second largest element in an Array.
4. Remove the duplicates from a sorted Array.
5. Find the smallest element in the given Array. 
6. Find the Third Largest Element in an Array.
7. Check if the Array is Sorted.
8. Reverse the given Array.
9. Write a program to replace every element with the greatest element on its right side.

        Expected Output: The given array is :7589685746
        After replace the modified array is: 9998877660

DAY-5

1. Leaders in Array.
2. Maximum sum subarray.
3. Container with most water.
4. Trapping rain water problem.
5. Print frequency of all the elements in a sorted Array.
6. In an Array of all 0s and 1s, find the largest lenght of all consecutive 1s.

        Input: The given array is : 1,1,1,0,0,1,1,1,1,0,1
        Output: 4

7. Move all 0s to the end of the given Array.

        Input: 8,0,3,0,0,5
        Output: 8,1,3,5,0,0,0

8. Trapping rain water problem in O(1) space complexity.
9. Minimum Sum Subarray problem.
10. Print the elements in the maximum sum subarray.
11. Stocks buy & sell problem.

DAY-6

1. Find if there is a subarray with 0 sum.
2. Transpose of a Matrix.
3. Rotate a Matrix 90 degree clockwise.
4. Search element in Row-wise and Column-wise Sorted Matrix.
5. Split array in three equal sum subarray.
6. Find the largest subarray with equal numbers of 0s and 1s.
7. Majority Elements Problem- Find the element that repeats more than n/2 times.
8. Left Rotate an Array by 1 step.
9. Left Rotate an Array by k steps.

DAY-7

1. Given an array arr[i], find the maximum j-i such that arr[j]>arr[i].
2. Find two numbers in a sorted Array with the given Sum.
3. Find three Numbers in an unsorted Array with the Given sum.

DAY-8 (Recursion & Backtracking)

1. Sum of n Natural Numbers using Resursion.
2. Power of a Number using Recursion.
3. Find the Number of paths in an nxm Matrix.
4. Check if an array is a Palindrome using Resursion.
5. Factorial of a number using Resursion.
6. Find the sum of square of N Natural numbers using Resursion.
7. Find the Greatest common divisor(GCD).

DAY-9

1. Find the sum of digits in a number using Recursion.
2. Generate all subsets/subsequence of a String.
3. Tower of Hanoi Problem.
4. Print all peermutations of a given String.
5. Rope Cutting Problem- Maximise the number of rods after cutting a rod with three given sizes.
6. Josephus Problem.

DAY-10

1. Rat in a Maze Problem.
2. N Queens Problem.
3. Sudoku Solver Problem.
4. Subset sum Problem.

DAY-11 (Mathematics)

1. Palindrome numbers.
2. GCD or HCF of two numbers.
3. LCM of two numbers.
4. Trailing Zeros in factorial.
5. Unique Paths in a grid.
6. Calculate square roots of an equation.

DAY-12

1. Check prime or not.
2. Efficient &
3. More Efficient solution for prime.
4. Print all divisors of N.
5. Sieve of Eratosthenes.
6. Fast power, Calculate pow(a,b).
7. Calculate a^b mod n for large values of a & b.
8. Prime factors of a given number.

DAY-13 (Bits Manipulation)

1. Find the "i"th bit.
2. Toggle the 'i'th bit.
3. Check if a number is power of two.
4. Count the number of set bits in a number.
5. Check if a number is even or odd.
6. Swap two numbers without using third variable.
7. Set the i th bit to 1.
8. Unset the i th bit/ change i th bit to 0.
9. Given a number N, the task to find the XOR of all numbers from 1 to N.
10. How many bits are required to change to convert to one number to another.

DAY-14

1. Find the only non-repeating element in an array where every other element repeats twice.
2. Find the two non-repeating element in an array where every other element repeats twice.
3. Swap two bits in a given integer.
4. Reverse the bits of an 32 bit unsigned integer.
5. Find the only non-repeating element in an array where every other element repeats thrice.

DAY-15 (Strings)

1. Check if two Strings are Anagram of each other.
2. Reverse the words in a given String.
3. Check if String is a subsequence of another string.
4. Find the leftmost character that repeats in a String.
5. Find the length of the last word in a given strring.

DAY-16

1. Patterrn matching.
2. Rabin Karp Algorithm.
3. Check if Strings are rotations.
4. Find the longest substring with distinct characters.

DAY-17 (Sorting Algorithms)

1. Bubble sort.
2. Insertion sort.
3. Selection sort.
4. Intersection of two sorted arrays.
5. Sort an array with three types of elements.
6. Union of two sorted arrays.
7. Find the minimun between two elements in an array.
8. Sort an array of two types of elements.

DAY-18

1. Quick sort.
2. Merge sort.
3. Given a set of Strings, find the longest common prefix using Divide and Conquer.
4. Strassen's Matrix Multiplication.
5. Find closest pair of points using Divide and Conquer algorithm.

DAY-19 (Binary Search)

1. Binary search.
2. Index of the first occurrence of an element in a sorted arrar.
3. Index of the last occurrence of an element in a sorted arrar.
4. Count the occurance of elements in a sorted array
5. Search in a sorted rotated array.
6. Find the first position of 1 in a sorted array containing only 0s and 1s.
7. Find the upper bound of an element in a sorted array.
8. Given a sorted array with no duplicates A and a target value B, return the index if the target is found. If not, rerturn the index where it would be if it were inserrted in order.

DAY-20

1. Search an element in an infinite sorted aray.
2. Find the square root of an integer.
3. Find the median of two sorted arrays.

DAY-21 [IC]

1. Tree cutting problem.
2. Books allocation problem.
3. Aggressive cows problem.
4. Given a matrix of integers A of size NxM in which each row is sorted. Find and return the overall median of the matrix A.
5. Painter's partition problem.

DAY-22 (Hashing)

1. Count distinct elements.
2. Frerquency of Elements in an array.
3. Pair with given sum in unsorted array.
4. Zero sum subaray.
5. Subarray with given sum.
6. Intersection of Two Arrays.
7. Union of two arrays.
8. Find largest subarray with zero sum.
9. Count distinct elements in every window of size k.

DAY-23

1. Largest subaarray with zero sum.
2. Longest consecutive subsequence.
3. Find any quadruple whose sum is equal to the given sum.
4. Longest Substring without repeat.

DAY-24 (LinkedList)

1. Traverse, insert, delete in a LinkedList.
2. Find the middle element in a LinkedList.
3. Delete an element whose pointer is given in a LinkedList.
4. Find the Kth element from last in a LinkedList.
5. Remove duplicates from a sorted LinkedList.
6. Sort a LinkedList using Bubble sort.
7. Find the intersection of two LinkedList.
8. Check if a Singly LinkedList ia a Palindrome.

DAY-25 

1. Reverse a LinkedList - iteratively.
2. Reverse a LinkedList - recursively.
3. Reverse a LinkedList in a group of k.
4. Detect a cycle in a LinkedList.
5. Palindrome LinkedList.
6. Rotate a LinkedList by k nodes.
7. Add two numbers (each digit is present inside a node of linkedList)
8. Merge a Linked List into another Linked List inside a node of Linked List.

DAY-26

1. Merge two sorted Linked Lists.
2. Palindrome Linked List.
3. Doubly Linked List implementation.
4. Implement LRU cache. 
5. Clone a Linked List with next and random pointer.
6. Given a Linked List A, reverse the order of all nodes at even positions.[IC]

DAY-27 (Stack) 

1. Implementation of Stack using Array.
2. Implementation of Stack using LinkedList.
3. Parenthesis matching problem.
4. Previous / Next greater element.
5. Previous / Next less element.
6. Reverse words in a given sentence.
7. Reverse a stack using recursion.
8. Reverse a stack without using extra space.[IC]
9. Delete the mid element from a given stack.

DAY-28 

1. Infix to postfix conversion.
2. Evaluate postfix expression.
3. Infix to prefix conversion.
4. Postfix expression to a prefix expression.

DAY-29

1. Implement two stacks using one array.
2. Find maximum area in a  histogram.
3. Find maximum area submatrix in a matrix.
4. Implement minStack using O(n) extra space.
5. implement k stack using Array. [IC]
6. Implement minStack using O(1) space.
7. Simply Directory Path.

DAY-30 (Queue) 

1. Implement queue using Linked List.
2. Implement queue using Array.
3. Implement queue using circular Array.
4. Implement queue using Two Stacks.
5. Implement stack using Two Queues.
6. Implement stack using One Queue.
7. Reverse a Queue.

DAY-31

1. Reverse the first k elements of a Queue.
2. Circular tour problem.
3. Sliding window maximum problem.
4. Flatten a multi-level linked List.

DAY-32 (Binary Tree)

1. Binary tree.
2. Inorder, preorder, postorder traversal in binary tree.
3. Height of a binary tree.
4. Print all the nodes present at a distance k from Root.
5. Size of a binary tree.
6. Maximum/ minimum in a binary tree.
7. Inorder, preorder, postorder traversal without using recursion.

DAY-33

1. Binary tree level order traversal [LC- 102].
2. Binary tree right side view [LC- 199].
3. Top view of a binary tree.
4. Print the zig-zag order traversal of a binary tree.
5. Print the left view of a binary tree.
6. Print the bottom view of a binary tree.
7. Modified vertical order traversal.[IC]
8. Cousins in a binary tree.
9. Populate the next pointer in each node.[IC]
10. Vertical Order Traversal of a Binary Tree.

DAY-34

1. Inorder/ preorder/ postorder traversal without recursion.
2. Diameter of a binary tree.
3. Postorder of a binary tree without using two stacks.
4. Morris traversal.

DAY-35

1. Print all the ancestors of a given node in a binary tree.
2. Lowest common ancestor of a binary tree.
3. Convert a binary tree to a doubly linkedlist.
4. Burn a binary tree starting from a leaf node.

DAY-36 (Binary Search Tree)

1. Search in BST.
2. Insert an element in a BST.
3. Delete an element in a BST.
4. Check if a binary tree is BST.
5. Convert a sorted array to balanced BST.
6. Check if a given array can represent preorder traversal of BST.
7. Second largest element in BST.
8. Print BST keys in given range.

DAY-37

1. Check if a binary tree is BST.
2. Shortest distance between two nodes in BST.
3. Find a pair with given target sum in a BST.
4. Find floor and ceil values in a BST.
5. Construct a BST from given preorder traversal.

DAY-38 (AVL Tree)

1. Insertion & Rotations.

Day-39 (Heap)

1. Insertion in heaps.
2. Deletion in heaps & heapify.
3. Implement insertion and deletion for MaxHeap.

DAY-40 (Priority queue)

1. Heap sort.
2. Find the kth largest element in an array.
3. Maximum sum of at most two non-overlapping intervals in a list of intervals.
4. Split Array into K non-overlapping subset such that maximum among all subset sum is minimum.
5. Maximize profit possible by selling M products such that profit of a product is the number of products left of that supplier.

DAY-41

1. Connect n ropes with minimum cost.
2. Split Array into K subset such that maximum among all subset sum is minimum.
3. Find the median in a running steam of numbers.
4. Merge k sorted lists.
5. Check if a given array represents a binary heap.
6. Magicians and chocolates.
7. N max pair combinations. [IC]

DAY-42 (Disjoint sets)

1. Implementation of union-find.
2. Union-find with rank.
3. Union-find with path compression.

DAY-43 (Graphs)

1. Graphs using adjacency list & matrix.
2. DFS traversal.
3. BFS traversal.

DAY-44

1. Number of connected components in a graph.
2. Shortest Path in a graph.
3. Detect a cycle in an undirected graph. 
4. Detect a cycle in an directed graph.
5. Chech weather a given graph is bipartite or not.
6. Check weather a path exists.

DAY-45

1. InDegree of a directed graph.
2. Topological sorting using DFS in a graph.
3. Kahn's algorithm - Topological sorting using BFS.
4. Detect a cycle in a directed graph using kahn's algorithm.
5. Shortest path in a directed acyclic graph. [IC]

DAY-46

1. Shortest path in a directed acyclic graph.
2. MST using kruskal algorithm.
3. Prim's algorithm.
4. Dijkstra's algorithm.

DAY-47 (Greedy algorithm)

1. Negative weight cycle in a graph.
2. Bellman Ford Algorithm.
3. Fractional knapsack problem.
4. Activity selection problem.
5. Wine selling problem.
6. Minimum product subset of an array.
7. Maximum sum of absolute difference of any permutation.[IC]

DAY-48

1. Minimum number of platforms.
2. Minimum cost to cut a board into squares.
3. Huffman Compression Algorithm.
4. Find maximum equal sum of every three stacks.
5. Paper cut into minimum number of squares.
6. Assign mice to holes.

DAY-49 (Dynamic programming)

1. Fibonacci series.
2. Coin change probelm.
3. Rod cutting problem.
4. Ugly numbers.
5. Permutations coefficient.
6. Tiling problem.
7. Compute nCr % p.

DAY-50

1. Longest common subsequence.
2. Minimum insertions/deletions to convert string a to string b.
3. Longest common palindrome subsequence.
4. Code LCS with space optimisation.
5. Minimum length of the supersequence of string s1 and string s2.
6. Longest repeating subsequence.

DAY-51

1. Edit distance problem.
2. Count number of ways to cover a distance.
3. Minimum jumps to reach the end.
4. Minimum jumps to reach the end- O(n).
5. LCS using binary search.
6. Given a set of non-negativev integers, and a value sum, determine if there is a subset of the given set with sum equal to given sum.








